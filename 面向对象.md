## 1. 简述面向对象与面向过程的区别

### 1.面向过程

面向过程的程序设计方法是一种结构化的程序设计方式。它是以过程为中性，按照一定的顺序和步骤，自顶向下逐步求精的一种程序设计方法。

### 2.面向对象

面向对象的编程思想是一种以事物为中心的编程模式。这种编程思想模式模拟了客观世界事物的真实存在方式，用更加符合常规的思维方式来处理客观世界的问题。



### 访问控制符

|            | `private` | `default` | `protected` | `public` |
| :--------: | :-------: | :-------: | :---------: | :------: |
| 同一个类中 |    OK     |    OK     |     OK      |    OK    |
| 同一个包中 |           |    OK     |     OK      |    OK    |
|   子类中   |           |           |     OK      |    OK    |
|  全局范围  |           |           |             |    OK    |



## 2. 什么是继承？`Java`继承有哪些特点？

继承是面向对象的一个重要特征，通过继承实现代码的复用。Java继承的主要特征包括：:one:不支持多重继承，可实现多个接口；:two:子类只能继承父类的非私有成员变量和方法；:three:子类可覆盖父类的成员变量和方法。



## 3.简述继承与组合的区别

继承和组合都是是实现代码的复用的方式，继承的子类与父类之间是一种“`is-a`”的关系，组合的新类和旧类之间是一种“`has-a`”的关系。

在实际应用中尽量少用继承，因为可能造成子类与父类之间的深度耦合，从而使代码变得臃肿而不利于维护，建议更多地使用组合的方式实现代码的复用。



## 4. 简述`overload`和`override`的区别

`overload`的意思是重载，是指在同一个类中定义了多个同名的函数，依赖函数的参数个数或参数的类型进行区分的一项技术。`override`的意思是覆盖，是指子类通过重写父类中的同名方法覆盖父类中的方法，覆盖是实现多态的基础。

>1. 子类的方法名、形参列表要与父类中的方法一致。
>2. 子类方法返回值类型应当与被覆盖的父类方法返回值类型相同。
>3. 子类方法声明抛出的异常类应当与父类方法声明抛出的异常类型相同。
>4. 子类方法的访问权限应该比父类中被覆盖方法的访问权限更大或相等。
>5. 子类中的`private`访问权限的方法在子类中不能被覆盖，因为该方法在子类中是不可见的。
>6. 覆盖方法和被覆盖方法要么都是类方法（`static`方法），要么都是实例方法（非`static`方法），不能一个是类方法，一个是实例方法。



## 5. 如何获取父类的类名？如何获取当前运行类的类名？

通过`this.getClass().getName()`获取当前运行类的名称。

通过`this.getClass().getSuperclass().getName()`获取当前运行类的父类的名字。



## 6. 构造函数能否被继承？能否被重载？

1. 子类不能继承父类的构造方法，但可以通过`super`引用调用父类的构造方法。
2. 构造方法可以被重载，同时在构造方法中可以通过`this`调用其他构造方法。

> 在`Java`的类中，一旦显示地定义了一个构造方法（无论是否带参数），那么系统不再提供默认的构造方法。
>
> 其实如果在子类的构造方法中既没有显示地使用`super`调用父类的构造方法，也没有使用this调用其他重载的构造方法，系统则会在执行子类的狗造方法之前，隐式地调用父类的无参的构造方法。不能用`super`和`this`同时调用构造方法。



## 7.简述静态块、非静态块和构造函数的初始化顺序

父类的静态初始化块-->子类的静态初始化块-->父类的初始化块-->父类的构造函数-->子类的始化块-->子类的构造函数。

> 一个类的静态初始化（代码）块只会在该类被加载到内存的时候执行一次；非静态（代码）块，每次创建一个对象，就会被执行一次。



## 8.简述抽象类与接口的相同点与差别

### 相同点：

1. 抽象类与接口都不能被实例化，他们都位于继承树的顶端，都是用于被其他类实现和继承的。

2. 抽象类与接口都可以包含抽象方法，而实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

###  不同点：

+ 语法层面上：

  1. 接口的定义中只能包含抽象方法，而不能包含已经提供实现的方法；抽象类中既可以包含抽象方法，也可以包含普通方法，甚至抽象类完全可以只包含普通的方法。
  2. 接口里不能定义静态方法，而抽象类中可以定义静态方法。
  3. 接口里只能定义静态常量属性，不能定义普通属性，而抽象类中两者都可以定义。
  4. 接口里不能定义构造方法，而抽象类中可以定义构造方法。但是抽象类中的构造方法不是用于创建对象的，而是为了让其子类调用这些构造方法来完成属于抽象类的初始化操作。
  5. 接口里不能包含初始化块，而抽象类中可以包含初始化块。
  6. 抽象类中的抽象方法的访问类型可以是`public`、`protected`，但接口中的抽象方法只能是`public`类型的，并且默认为`pubic abstract`类型。
  7. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中的变量只能是`public static final` 类型，并且默认为`public static final`类型。
  8. 一个类最对只能包含一个直接父类，包括抽象类，但是一个类可以实现多个接口。
  
+ 设计层面

   接口是一种规范或者叫做契约，规定了实现者必须向外提供哪些服务。而抽象类则是系统中多个子类的公共父类，它更多体现的是一种设计模式，未实现的抽象方法则需要其子类进一步完善。



## 9.`Java`抽象类可以是`final`的吗？

`Java`中的抽象类不可以是`final`的。

> 抽象类存在的意义就在于被继承。
>
> `Java`中`abstract`和`final`本身就是互斥的，两者同时作用于同一个类时将会产生编译的错误。



## 10. 简述`Static Nested Class` 和 `Inner Class` 的区别

`Static Nested Class`是静态成员内部类，`Inner Class`是一般的非静态成员内部类。静态成员内部类是类相关的内部类，他不能访问其外部类的实例成员，只能访问其外部类的类成员。非静态成员内部类是对象相关的内部类，因为在非静态成员内部类的对象中保存了一个寄存的外部类对象的引用，所以在非静态成员内部类里可以直接访问其外部类的成员变量和方法。

## 11. 什么是匿名内部类？使用匿名内部类需要注意什么？

匿名内部类就是一种没有显示定义名字的内部类。匿名内部类适用于那种只需要使用一次的类。在创建匿名内部类时会同时创建一个该类的对象，并且该匿名内部类不能被重复使用。

> 1. 匿名内部类不能有构造方法。
> 2. 匿名内部类不能定义任何静态成员、方法和类。
> 3. 匿名内部类不能是`public`、`protected`、`private`、`static`。
> 4. 只能创建匿名内部类的一个实例。
> 5. 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
> 6. 因为匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。



  

