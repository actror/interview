## 1. 简述什么是线程？进程和线程有什么区别？

1. 线程是进程的执行单元，线程是操作系统能够进行运算调度的最小单位。

2. 线程和进程的关系是“多对一”的关系。即一个进程可以拥有多个线程，而一个线程只能拥有一个父进程。

3. 关于线程独享和共享的资源：线程可独享自己的堆栈、程序计数器和局部变量；但线程必须于父进程的其他线程共享代码段、数据段、堆空间等系统资源。

   > + 线程可以拥有自己的堆栈、自己的程序计数器及自己的局部变量，但是线程不能拥有系统资源，它与其父进程的其他线程共享进程中的全部资源。
   > + 一个进程可以包含多个线程，但至少要包含一个线程，即主线程。
   >   1. 同一进程下的不同线程的调度不由程序控制。
   >   2. 线程独享自己的堆栈程序计数器和局部变量。
   >   3. 两个线程将并发执行。



## 2. `Java` 中的多线程有几种实现方法？启动一个线程是用`run`还是`start`？

启动一个线程必须调用`Thread`类的`start()`方法，使该线程处于就绪状态，这样该线程就可以被处理器调度。`run()`方法是一个线程所关联的执行代码，无论是派生自`Thread`类的线程类，还是实现`Runnable`接口的类，都必须实现`run()`方法，`run()`方法是该线程的执行代码。

>1. 继承Thread类
>2. 实现Runnable
>3. 实现Callable
>4. 创建线程池



## 3. 简述Java中的Runnable和Callable有什么不同？

`Callable`接口是一个泛型接口，它定义的`call()`方法类似于`Runnable`的`run()`方法，是线程所关联的执行代码。但是与`run()`方法不同的是，`call()`方法具有返回值，并且泛型接口的参数V指定了`call()`方法的返回值类型。同时，如果`call()`方法得不到返回值会抛出一个异常，而在`Runnable`的`run()`方法中不能抛出异常。

>`Future`接口定义了一组对`Runnable`或者`Callable`任务的执行结果进行取消、查询、获取结果、设置结果等操作。其中`get()`方法用于获取`call()`的返回值，它会发生阻塞，直到`call()`返回结果。
>
>+ 线程的状态（生命周期）
>
>![线程生命周期](imgs\3.png)
>
>当使用`new`关键字创建一个线程对象后，该线程就处于新建状态。
>
>当调用了线程对象的`start`方法后，该线程就处于就绪状态。
>
>一旦处于就绪状态的线程获得**CPU**开始运行，该线程就会进入运行状态。
>
>---
>
>***当一个正在运行的线程遇到如下情况时，线程会从运行状态转为阻塞状态***
>
>1. 线程调用`sleep`、`join`等方法。
>
>2. 线程调用了一个阻塞式**IO**方法。
>
>3. 线程试图获得一个同步监视器，但是该监视器正在被其他线程持有。
>
>4. 线程在等待某个`notify`通知。
>
>5. 程序调用了线程的`suspend`方法将该线程挂起。
>
>---
>
>+    当一个线程执行结束后，该线程进入死亡状态。
>1. `run`方法执行完毕。
>2. 线程抛出一个异常或错误，而该异常或错误未被捕获。
>3. 调用线程的`stop`方法结束该线程。
>



## 4.简述`sleep`方法和`wait`的区别，`sleep`方法和`yield`方法的区别

1. `sleep`方法和`wait`的区别
+  `sleep`方法是`Thread`类的一个静态方法，其作用是使运行中的线程暂时停止指定的毫秒数，从而该线程进入阻塞状态并让出处理器，将执行的机会让给其他线程。但是这个过程中监控状态始终保持，当`sleep`的时间到了之后线程会自动恢复。
+ `wait`是`Object`类的方法，它是用来实现线程的同步的。当调用某个对象的`wait`方法后，当前线程会被阻塞并释放同步锁，直到其他线程调用了该对象的`notify`方法或者`notifyAll`方法来唤醒该线程。所以`wait`方法和`notify`（或`notifyAll`）应当成对出现以保证线程间的协调运行。
2. `sleep`方法和`yield`方法的区别

+ `sleep`方法暂停当前线程后，会给其他线程执行机会而不会考虑其他线程的优先级。但yield方法只会给优先级相同或者更高的线程执行机会。
+ `sleep`方法执行后线程会进入阻塞状态，而执行了`yield`方法后，当前线程会进入就绪状态。
+ 由于`sleep`方法的声明抛出了`InterruptedException`异常，所以在调用`sleep`方法时需要`catch`捕获该异常或抛出该异常，而`yield`方法没有声明抛出异常。



## 5.简述`Java`中为什么不建议使用`stop`和`suspend`方法终止线程

`stop`方法是线程不安全的，可能产生不可预料的结果；`suspend`方法可能导致死锁.



## 6. 如何终止一个线程

1. 当一个线程处于运行状态时，可通过设置退出标志的方法安全结束该线程；
2. 当一个线程被阻塞而无法正常运行时，可以抛出一个异常使其退出阻塞状态，并catch住该异常从而安全结束该线程。

```java
public class Test {
    private static volatile boolean exit = false;

    public static void main(String[] args) {
        new Thread() {
            @Override
            public void run() {
                System.out.println("thread start......");
                while (! exit) {     //死循环，正常情况下不会停止
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("thread run......");
                }
                System.out.println("thread end......");
            };
        }.start();
        
        new Thread() {   //在另一个线程中终止上面这个线程
            @Override
            public void run() {
                try {
                    Thread.sleep(1000 * 5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                exit = true;  //5s后更改退出标志的值
            }
        }.start();
    }
}
```



## 7. 简述`synchronized`和`Lock`的区别

1. 锁机制不同

   + `synchronized`使用的是`Object`对象，即同步监视器`notify`、`wait`、`notifyAll`调度     机制来保证线程同步和协调执行。而使用`Lock`对象来保证线程同步时，系统提供了一个人`Condition`类来保持线程间的协调，系统中不存在隐式的同步监视器对象， 因此不能使用`notify`、`wait`、`notifyAll`等方法来进行线程的调度。
   + 此外，`synchronized`获得锁和释放锁都是在一个块结构中，当获得多个锁时，他们必须以相反的锁顺序释放。同时`synchronized`支持自动解锁，因此不会出现因为锁没有被释放而导致的死锁发生。`Lock`机制则需要程序显示地释放锁，否则可能会导致死锁的发生。
2. 用法不同
   + 使用`synchronized`进行线程同步时，`synchronized`可加在方法上，也可以加在待定的代码块上，而同步监视器必须是`Object`类的对象，即必须是应用类型的对象。`Lock`机制需要显示地指定加锁的起始位置和终止位置。`synchronized`的锁机制是托管给`JVM`执行，而`Lock`是锁机制是通过代码实现的。
3. 性能不同

   + 在资源竞争不是很激烈的情况下，`synchronized`的性能要由于`Lock`的性能（例如，可重入锁`ReentrantLock`），但是在资源竞争很激烈的情况下，`synchronized`的性能会下降得非常快，而`Lock`的性能则变化不大。所以应当结合实际的应用场景选择使用`synchronized`安全机制或`Lock`安全机制。
   + 与此同时，`Lock`还提供了`synchronized`所没有的其他功能。例如，使用非块结构的`tryLock()`方法、获取可中断锁的`lockInterruptibly()`方法、获取超时失效锁的`tryLock(long TimeUnit)`方法等。其功能更加强大，使用更加灵活。

> 1. `Lock`的功能更加强大，`Lock`能完成`synchronized`实现的所有功能。
> 2. 在很多数据结构和框架的设计中，在实现线程同步时采用`Lock`而非`synchronized`。



---

> `Java`中提供四种线程通信机制：
>
> 1. `wait()`/`notify()`方法
> 2. `await()`/`signal()`方法
> 3. `BlockingQueue`阻塞队列方法
> 4. `PipedInputStream`/`PipedOutputStream`方法

---

> 守护线程：
>
> + :smirk:当一个程序中的所有用户线程都执行完毕后`JVM`会退出，此时守护线程无论是否已被执行完都会被“杀死”。相反，如果一个程序中还存在未被执行完的用户程序，则`JVM`不会退出，守护线程也将继续执行。
> + 守护线程存在的意义就是为其他非守护线程服务的，当其他非守护线程都执行完毕后，守护线程自然也就完成了它的使命而终止。





 









